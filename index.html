<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ChromaShift</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #050507;
            color: #fff;
            font-family: 'SF Mono', 'Fira Code', 'Consolas', monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            -webkit-touch-callout: none;
        }

        canvas { display: block; width: 100vw; height: 100vh; height: 100dvh; }

        /* ====== HUD ====== */
        #hud {
            position: fixed; top: 0; left: 0; right: 0;
            padding: 20px 28px;
            display: flex; justify-content: space-between; align-items: flex-start;
            pointer-events: none; z-index: 10;
        }

        #hud-left { display: flex; flex-direction: column; gap: 4px; }

        #title {
            font-size: 13px; font-weight: 600; letter-spacing: 6px;
            text-transform: uppercase; color: #1e1e1e;
        }

        #combo-text {
            font-size: 13px; letter-spacing: 3px; text-transform: uppercase;
            color: transparent; transition: color 0.3s, text-shadow 0.3s, transform 0.15s;
            transform-origin: left center;
        }

        #combo-text.visible { color: #ffd93d; text-shadow: 0 0 20px rgba(255,217,61,0.25); }
        #combo-text.pop { transform: scale(1.2); }

        #hud-right { display: flex; flex-direction: column; align-items: flex-end; gap: 2px; }

        #score {
            font-size: 38px; font-weight: 900; letter-spacing: 1px; line-height: 1;
            transition: transform 0.08s; text-shadow: 0 0 30px rgba(255,255,255,0.05);
        }

        #score.bump { transform: scale(1.18); }

        #level-display { font-size: 11px; letter-spacing: 3px; text-transform: uppercase; color: #2a2a2a; }

        #lives-display { display: flex; gap: 5px; margin-top: 8px; }

        .life-pip {
            width: 10px; height: 10px; border-radius: 50%; background: #ff6b6b;
            transition: opacity 0.4s, transform 0.4s; box-shadow: 0 0 8px rgba(255,107,107,0.3);
        }

        .life-pip.lost { opacity: 0.1; transform: scale(0.4); box-shadow: none; }

        /* ====== COLOR HUD ====== */
        #color-hud {
            position: fixed; bottom: 34px; left: 50%; transform: translateX(-50%);
            display: flex; align-items: center; gap: 18px;
            z-index: 10; pointer-events: none;
        }

        #color-ring-container {
            position: relative; width: 78px; height: 78px;
            filter: drop-shadow(0 0 16px rgba(0,0,0,0.7));
        }

        #color-ring { width: 78px; height: 78px; }

        #color-center {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 44px; height: 44px; border-radius: 10px;
            transition: background-color 0.1s, box-shadow 0.1s, transform 0.15s;
        }

        #color-center.pulse { animation: centerPulse 0.3s ease; }

        @keyframes centerPulse {
            0% { transform: translate(-50%,-50%) scale(1); }
            40% { transform: translate(-50%,-50%) scale(1.2); }
            100% { transform: translate(-50%,-50%) scale(1); }
        }

        #next-colors { display: flex; gap: 10px; align-items: center; }

        .next-color-dot {
            height: 22px; border-radius: 6px;
            border: 1px solid rgba(255,255,255,0.04);
            transition: background-color 0.2s, transform 0.2s, width 0.2s;
        }

        .next-color-dot:nth-child(1) { width: 26px; opacity: 0.7; }
        .next-color-dot:nth-child(2) { width: 20px; opacity: 0.35; }
        .next-color-dot:nth-child(3) { width: 16px; opacity: 0.15; }

        #hint-text {
            position: fixed; bottom: 124px; left: 50%; transform: translateX(-50%);
            font-size: 11px; color: #1a1a1a; letter-spacing: 3px;
            text-transform: uppercase; pointer-events: none; z-index: 10;
            white-space: nowrap; transition: opacity 0.8s;
        }

        /* ====== SCREEN FX ====== */
        #game.shake { animation: screenShake 0.35s ease; }

        @keyframes screenShake {
            0%,100% { transform: translate(0,0) rotate(0); }
            10% { transform: translate(-5px,3px) rotate(-0.3deg); }
            25% { transform: translate(4px,-4px) rotate(0.2deg); }
            40% { transform: translate(-3px,5px) rotate(-0.2deg); }
            55% { transform: translate(5px,-2px) rotate(0.3deg); }
            70% { transform: translate(-4px,3px) rotate(-0.1deg); }
            85% { transform: translate(2px,-3px) rotate(0.1deg); }
        }

        /* ====== OVERLAYS ====== */
        .overlay {
            position: fixed; inset: 0;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(3,3,5,0.95); z-index: 20; gap: 14px;
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            animation: fadeIn 0.4s ease;
            overflow-y: auto; -webkit-overflow-scrolling: touch;
            padding: 40px 20px;
        }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .overlay h1 {
            font-size: 52px; font-weight: 900; letter-spacing: 10px; text-transform: uppercase;
            background: linear-gradient(135deg, #ff6b6b, #ffd93d, #6bcb77, #4d96ff, #e056a0, #ff6b6b);
            background-size: 500% 500%;
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            animation: gradShift 6s ease infinite;
        }

        @keyframes gradShift {
            0%,100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .overlay .subtitle {
            font-size: 11px; letter-spacing: 8px; text-transform: uppercase;
            color: #222; margin-top: -6px;
        }

        .overlay p {
            color: #3a3a3a; font-size: 14px; max-width: 420px;
            text-align: center; line-height: 2;
        }

        .overlay p strong { color: #777; }

        .btn {
            margin-top: 18px; padding: 16px 50px;
            border: 1px solid #151515; background: #0a0a0c; color: #fff;
            border-radius: 12px; font-family: inherit; font-size: 14px;
            font-weight: 600; letter-spacing: 4px; text-transform: uppercase;
            cursor: pointer; pointer-events: all; transition: all 0.25s;
            position: relative; overflow: hidden;
        }

        .btn::before {
            content: ''; position: absolute; inset: 0;
            background: linear-gradient(135deg, #ff6b6b15, #4d96ff15);
            opacity: 0; transition: opacity 0.3s;
        }

        .btn:hover {
            border-color: #2a2a2a; transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(0,0,0,0.6);
        }

        .btn:hover::before { opacity: 1; }
        .btn:active { transform: translateY(0); }

        #game-over h1 {
            -webkit-text-fill-color: #fff; background: none;
            font-size: 18px; letter-spacing: 8px; color: #444;
        }

        #final-score { font-size: 76px; font-weight: 900; line-height: 1; }

        #best-score-text { color: #ffd93d; font-size: 13px; letter-spacing: 2px; }

        #new-best {
            display: none; font-size: 11px; letter-spacing: 5px;
            text-transform: uppercase; color: #ffd93d; animation: pulse 1.2s ease infinite;
        }

        @keyframes pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }

        #death-msg { color: #ff6b6b; font-size: 12px; letter-spacing: 2px; }

        #stats-row { display: flex; gap: 36px; margin-top: 10px; }

        .stat { display: flex; flex-direction: column; align-items: center; gap: 3px; }
        .stat-val { font-size: 22px; font-weight: 700; }
        .stat-label { font-size: 10px; letter-spacing: 2px; text-transform: uppercase; color: #333; }

        /* ====== LEADERBOARD ====== */
        #leaderboard {
            margin-top: 14px; width: 320px; max-height: 220px; overflow: hidden;
        }

        #leaderboard h3 {
            font-size: 10px; letter-spacing: 4px; text-transform: uppercase;
            color: #333; margin-bottom: 8px; text-align: center;
        }

        .lb-row {
            display: flex; align-items: center; justify-content: space-between;
            padding: 6px 12px; border-radius: 8px; margin-bottom: 3px;
            font-size: 12px; transition: background 0.2s;
        }

        .lb-row:nth-child(2) { background: rgba(255,217,61,0.06); }
        .lb-row:nth-child(3) { background: rgba(255,255,255,0.03); }
        .lb-row:nth-child(4) { background: rgba(255,255,255,0.02); }

        .lb-row.current { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); }

        .lb-rank { color: #444; font-weight: 700; width: 24px; }
        .lb-rank.gold { color: #ffd93d; }
        .lb-rank.silver { color: #aaa; }
        .lb-rank.bronze { color: #cd7f32; }
        .lb-name { flex: 1; color: #888; margin-left: 8px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .lb-score { font-weight: 700; color: #fff; margin-left: 12px; }
        .lb-level { font-size: 10px; color: #444; margin-left: 8px; }

        /* Name input */
        #name-input-row {
            display: none; flex-direction: column; align-items: center; gap: 8px; margin-top: 8px;
        }

        #name-input-row label {
            font-size: 10px; letter-spacing: 3px; text-transform: uppercase; color: #444;
        }

        #player-name {
            width: 200px; padding: 10px 16px; border-radius: 10px;
            border: 1px solid #1a1a1a; background: #0a0a0c; color: #fff;
            font-family: inherit; font-size: 14px; text-align: center;
            letter-spacing: 2px; outline: none; transition: border-color 0.2s;
        }

        #player-name:focus { border-color: #333; }
        #player-name::placeholder { color: #2a2a2a; }

        /* New color announcement */
        #new-color-text {
            position: fixed; top: 42%; left: 50%;
            transform: translate(-50%,-50%) scale(0.5);
            font-size: 18px; font-weight: 700; letter-spacing: 6px;
            text-transform: uppercase; pointer-events: none; z-index: 19; opacity: 0;
        }

        #new-color-text.show { animation: newColorAnim 1.5s cubic-bezier(0.16,1,0.3,1) forwards; }

        @keyframes newColorAnim {
            0% { opacity: 0; transform: translate(-50%,-50%) scale(0.5); }
            10% { opacity: 1; transform: translate(-50%,-50%) scale(1.1); }
            20% { transform: translate(-50%,-50%) scale(1); }
            60% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%,-55%) scale(1); }
        }

        /* ====== COMBO TIER ANNOUNCEMENT ====== */
        #combo-tier-text {
            position: fixed; top: 38%; left: 50%;
            transform: translate(-50%,-50%) scale(0.5);
            font-weight: 900; letter-spacing: 8px;
            text-transform: uppercase; pointer-events: none;
            z-index: 19; opacity: 0;
        }

        #combo-tier-text.show { animation: comboTierAnim 1.4s cubic-bezier(0.16,1,0.3,1) forwards; }

        @keyframes comboTierAnim {
            0% { opacity: 0; transform: translate(-50%,-50%) scale(0.3); }
            8% { opacity: 1; transform: translate(-50%,-50%) scale(1.2); }
            18% { transform: translate(-50%,-50%) scale(1); }
            55% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%,-55%) scale(1); }
        }

        #combo-multiplier {
            position: fixed; top: 44%; left: 50%;
            transform: translateX(-50%);
            font-size: 16px; font-weight: 700; letter-spacing: 4px;
            pointer-events: none; z-index: 19; opacity: 0;
        }

        #combo-multiplier.show { animation: comboMultAnim 1.4s cubic-bezier(0.16,1,0.3,1) forwards; }

        @keyframes comboMultAnim {
            0% { opacity: 0; transform: translateX(-50%) translateY(5px); }
            12% { opacity: 0.8; transform: translateX(-50%) translateY(0); }
            55% { opacity: 0.8; }
            100% { opacity: 0; transform: translateX(-50%) translateY(-5px); }
        }

        /* ====== VOLUME ====== */
        #vol-btn {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            z-index: 25; width: 38px; height: 38px; border-radius: 10px;
            border: 1px solid #141414; background: #080808; color: #333;
            font-size: 15px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            transition: all 0.2s;
        }

        #vol-btn:hover { border-color: #2a2a2a; color: #666; }

        /* ====== LEVEL UP ====== */
        #level-flash {
            position: fixed; inset: 0; pointer-events: none; z-index: 18; opacity: 0;
        }

        #level-flash.active { animation: lvlFlash 0.7s ease-out forwards; }

        @keyframes lvlFlash {
            0% { opacity: 1; background: rgba(255,217,61,0.06); }
            100% { opacity: 0; background: transparent; }
        }

        #level-up-text {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%,-50%) scale(0.5);
            font-size: 30px; font-weight: 900; letter-spacing: 10px;
            text-transform: uppercase; color: #ffd93d;
            pointer-events: none; z-index: 19; opacity: 0;
            text-shadow: 0 0 40px rgba(255,217,61,0.2);
        }

        #level-up-text.show { animation: lvlText 1.2s cubic-bezier(0.16,1,0.3,1) forwards; }

        @keyframes lvlText {
            0% { opacity: 0; transform: translate(-50%,-50%) scale(0.5); }
            12% { opacity: 1; transform: translate(-50%,-50%) scale(1.15); }
            25% { transform: translate(-50%,-50%) scale(1); }
            65% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%,-55%) scale(1); }
        }

        /* ====== MOBILE D-PAD ====== */
        #mobile-dpad {
            display: none; position: fixed;
            bottom: calc(28px + env(safe-area-inset-bottom, 0px));
            right: 28px;
            z-index: 15; pointer-events: all;
        }

        .dpad-btn {
            position: absolute; width: 56px; height: 56px; border-radius: 14px;
            background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.05);
            color: #282828; font-size: 18px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; -webkit-tap-highlight-color: transparent;
            transition: background 0.08s, transform 0.08s;
        }

        .dpad-btn:active { background: rgba(255,255,255,0.08); transform: scale(0.92); }

        #dpad-up    { top: 0; left: 59px; }
        #dpad-down  { top: 118px; left: 59px; }
        #dpad-left  { top: 59px; left: 0; }
        #dpad-right { top: 59px; left: 118px; }

        /* ====== MOBILE RESPONSIVE ====== */
        @media (max-width: 768px), (pointer: coarse) {
            #mobile-dpad { display: block; }
            #hint-text { display: none; }
            #color-hud {
                bottom: calc(200px + env(safe-area-inset-bottom, 0px));
                gap: 12px;
            }
            #color-ring-container { width: 60px; height: 60px; }
            #color-ring { width: 60px; height: 60px; }
            #color-center { width: 34px; height: 34px; border-radius: 8px; }
            #score { font-size: 28px; }
            #title { font-size: 11px; letter-spacing: 4px; }
            #hud { padding: 14px 16px; }
            #vol-btn {
                top: auto;
                bottom: calc(20px + env(safe-area-inset-bottom, 0px));
                left: 20px; transform: none;
            }
            /* Overlays */
            .overlay { gap: 10px; padding: 20px; }
            .overlay h1 { font-size: 32px; letter-spacing: 6px; }
            .overlay .subtitle { font-size: 9px; letter-spacing: 5px; }
            .overlay p { font-size: 12px; max-width: 90vw; line-height: 1.8; }
            .btn { padding: 14px 36px; font-size: 13px; letter-spacing: 3px; }
            /* Game Over screen */
            #game-over h1 { font-size: 14px; letter-spacing: 6px; }
            #final-score { font-size: 48px; }
            #best-score-text { font-size: 11px; }
            #death-msg { font-size: 11px; }
            #stats-row { gap: 20px; margin-top: 6px; flex-wrap: wrap; justify-content: center; }
            .stat-val { font-size: 18px; }
            .stat-label { font-size: 9px; }
            /* Leaderboard */
            #leaderboard { width: min(320px, 85vw); max-height: 180px; margin-top: 8px; }
            .lb-row { padding: 5px 10px; font-size: 11px; }
            .lb-name { max-width: 80px; }
            /* Name input */
            #player-name { width: min(200px, 60vw); font-size: 13px; padding: 8px 14px; }
            /* Announcements — shift down to center of actual play area */
            #level-up-text { font-size: 22px; letter-spacing: 6px; top: 42%; }
            #new-color-text { font-size: 14px; letter-spacing: 4px; top: 38%; }
            #combo-tier-text { letter-spacing: 5px; top: 42%; }
            #combo-multiplier { font-size: 13px; letter-spacing: 3px; top: 48%; }
        }

        /* Extra small screens (iPhone SE, etc.) */
        @media (max-width: 380px) {
            #mobile-dpad {
                bottom: calc(16px + env(safe-area-inset-bottom, 0px));
                right: 16px;
            }
            .dpad-btn { width: 48px; height: 48px; border-radius: 12px; font-size: 16px; }
            #dpad-up    { top: 0; left: 51px; }
            #dpad-down  { top: 102px; left: 51px; }
            #dpad-left  { top: 51px; left: 0; }
            #dpad-right { top: 51px; left: 102px; }
            #color-hud { bottom: calc(170px + env(safe-area-inset-bottom, 0px)); }
            #color-ring-container { width: 50px; height: 50px; }
            #color-ring { width: 50px; height: 50px; }
            #color-center { width: 28px; height: 28px; }
            .overlay h1 { font-size: 26px; letter-spacing: 4px; }
            #final-score { font-size: 40px; }
            #stats-row { gap: 14px; }
            #score { font-size: 24px; }
            #hud { padding: 10px 12px; }
            .next-color-dot:nth-child(1) { width: 20px; height: 18px; }
            .next-color-dot:nth-child(2) { width: 16px; height: 18px; }
            .next-color-dot:nth-child(3) { width: 12px; height: 18px; }
        }

        /* Landscape mobile */
        @media (max-height: 500px) and (pointer: coarse) {
            #mobile-dpad { bottom: 10px; right: 10px; }
            .dpad-btn { width: 44px; height: 44px; font-size: 14px; }
            #dpad-up    { top: 0; left: 47px; }
            #dpad-down  { top: 94px; left: 47px; }
            #dpad-left  { top: 47px; left: 0; }
            #dpad-right { top: 47px; left: 94px; }
            #color-hud { bottom: auto; top: 50%; left: 20px; transform: translateY(-50%); flex-direction: column; }
            #hud { padding: 8px 12px; }
            #score { font-size: 22px; }
            #vol-btn { bottom: 10px; left: 10px; width: 32px; height: 32px; font-size: 12px; }
            .overlay { gap: 6px; padding: 12px; }
            .overlay h1 { font-size: 22px; }
            #final-score { font-size: 36px; }
            #stats-row { gap: 12px; }
            .stat-val { font-size: 16px; }
            #leaderboard { max-height: 120px; }
        }
    </style>
</head>
<body>

<canvas id="game"></canvas>
<div id="level-flash"></div>
<div id="level-up-text"></div>
<div id="new-color-text"></div>
<div id="combo-tier-text"></div>
<div id="combo-multiplier"></div>
<button id="vol-btn" title="Toggle Sound">♫</button>

<div id="hud">
    <div id="hud-left">
        <div id="title">ChromaShift</div>
        <div id="combo-text">COMBO x0</div>
    </div>
    <div id="hud-right">
        <div id="score">0</div>
        <div id="level-display">Level 1</div>
        <div id="lives-display">
            <div class="life-pip" id="life1"></div>
            <div class="life-pip" id="life2"></div>
            <div class="life-pip" id="life3"></div>
        </div>
    </div>
</div>

<div id="color-hud">
    <div id="color-ring-container">
        <svg id="color-ring" viewBox="0 0 78 78">
            <circle cx="39" cy="39" r="34" fill="none" stroke="#0e0e0e" stroke-width="4"/>
            <circle id="timer-arc" cx="39" cy="39" r="34" fill="none" stroke="#fff"
                    stroke-width="4" stroke-linecap="round"
                    stroke-dasharray="213.63" stroke-dashoffset="0"
                    transform="rotate(-90 39 39)"/>
        </svg>
        <div id="color-center"></div>
    </div>
    <div id="next-colors">
        <div class="next-color-dot" id="next1"></div>
        <div class="next-color-dot" id="next2"></div>
        <div class="next-color-dot" id="next3"></div>
    </div>
</div>

<div id="hint-text">Frecce o WASD &mdash; muoviti solo sulle celle del tuo colore</div>

<div class="overlay" id="start-screen">
    <h1>ChromaShift</h1>
    <div class="subtitle">color survival</div>
    <p>
        Il tuo quadrato <strong>cambia colore</strong> automaticamente.<br>
        Puoi muoverti <strong>solo sulle celle</strong> del tuo stesso colore.<br>
        Colore sbagliato = <strong>perdi una vita</strong>.<br>
        Sopravvivi il piu a lungo possibile.
    </p>
    <button class="btn" id="start-btn">Gioca</button>
</div>

<div class="overlay" id="game-over" style="display:none;">
    <h1>Game Over</h1>
    <div id="final-score">0</div>
    <div id="new-best">Nuovo Record!</div>
    <div id="best-score-text"></div>
    <div id="stats-row">
        <div class="stat"><span class="stat-val" id="stat-moves">0</span><span class="stat-label">Mosse</span></div>
        <div class="stat"><span class="stat-val" id="stat-level">1</span><span class="stat-label">Livello</span></div>
        <div class="stat"><span class="stat-val" id="stat-combo">0</span><span class="stat-label">Max Combo</span></div>
        <div class="stat"><span class="stat-val" id="stat-mult">x1</span><span class="stat-label">Max Mult</span></div>
    </div>
    <div id="death-msg"></div>
    <div id="name-input-row">
        <label>Il tuo nome</label>
        <input type="text" id="player-name" placeholder="AAA" maxlength="12" autocomplete="off" spellcheck="false">
    </div>
    <div id="leaderboard"><h3>Classifica</h3></div>
    <button class="btn" id="restart-btn">Riprova</button>
</div>

<div id="mobile-dpad">
    <div class="dpad-btn" id="dpad-up">▲</div>
    <div class="dpad-btn" id="dpad-down">▼</div>
    <div class="dpad-btn" id="dpad-left">◀</div>
    <div class="dpad-btn" id="dpad-right">▶</div>
</div>

<script>
(() => {
    // ============================================================
    //  AUDIO ENGINE — Full procedural sound design
    // ============================================================
    let ac = null;        // AudioContext
    let master = null;    // master gain
    let compressor = null;
    let reverb = null;    // convolver for reverb
    let reverbGain = null;
    let dryGain = null;
    let muted = false;

    // Pentatonic scale (C major pentatonic across octaves)
    const SCALE = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25, 587.33, 659.25, 783.99];

    async function initAudio() {
        if (ac) return;
        ac = new (window.AudioContext || window.webkitAudioContext)();

        // Master chain: dry + reverb → compressor → master gain → destination
        compressor = ac.createDynamicsCompressor();
        compressor.threshold.value = -18;
        compressor.knee.value = 12;
        compressor.ratio.value = 4;
        compressor.attack.value = 0.003;
        compressor.release.value = 0.15;

        master = ac.createGain();
        master.gain.value = 0.5;
        compressor.connect(master);
        master.connect(ac.destination);

        // Reverb send
        dryGain = ac.createGain();
        dryGain.gain.value = 1;
        dryGain.connect(compressor);

        reverbGain = ac.createGain();
        reverbGain.gain.value = 0.35;

        reverb = ac.createConvolver();
        reverb.buffer = createReverbIR(2.2, 4);
        reverbGain.connect(reverb);
        reverb.connect(compressor);
    }

    // Procedural reverb impulse response
    function createReverbIR(duration, decay) {
        const len = ac.sampleRate * duration;
        const buf = ac.createBuffer(2, len, ac.sampleRate);
        for (let ch = 0; ch < 2; ch++) {
            const data = buf.getChannelData(ch);
            for (let i = 0; i < len; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decay);
            }
        }
        return buf;
    }

    function send(node) {
        // Connect to both dry and reverb send
        node.connect(dryGain);
        node.connect(reverbGain);
    }

    // ---- SOUND: Move ----
    function sndMove(colorIdx, dir) {
        if (!ac || muted) return;
        const t = ac.currentTime;
        const note = SCALE[colorIdx % SCALE.length];

        // Sine body
        const o1 = ac.createOscillator();
        o1.type = 'sine';
        o1.frequency.value = note;
        const g1 = ac.createGain();
        g1.gain.setValueAtTime(0.18, t);
        g1.gain.exponentialRampToValueAtTime(0.001, t + 0.14);
        o1.connect(g1);
        send(g1);
        o1.start(t); o1.stop(t + 0.14);

        // Octave shimmer
        const o2 = ac.createOscillator();
        o2.type = 'sine';
        o2.frequency.value = note * 2;
        const g2 = ac.createGain();
        g2.gain.setValueAtTime(0.06, t);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        o2.connect(g2);
        send(g2);
        o2.start(t); o2.stop(t + 0.1);

        // Stereo pan based on direction
        const pan = ac.createStereoPanner();
        if (dir === 'left') pan.pan.value = -0.4;
        else if (dir === 'right') pan.pan.value = 0.4;
        else pan.pan.value = 0;

        // Percussive click
        const click = ac.createOscillator();
        click.type = 'square';
        click.frequency.value = 1200;
        const clickG = ac.createGain();
        clickG.gain.setValueAtTime(0.04, t);
        clickG.gain.exponentialRampToValueAtTime(0.001, t + 0.02);
        const clickF = ac.createBiquadFilter();
        clickF.type = 'highpass';
        clickF.frequency.value = 800;
        click.connect(clickF);
        clickF.connect(clickG);
        clickG.connect(pan);
        pan.connect(dryGain);
        click.start(t); click.stop(t + 0.02);
    }

    // ---- SOUND: Color change (whoosh) ----
    function sndColorChange() {
        if (!ac || muted) return;
        const t = ac.currentTime;

        // White noise burst filtered
        const bufLen = ac.sampleRate * 0.12;
        const nBuf = ac.createBuffer(1, bufLen, ac.sampleRate);
        const nData = nBuf.getChannelData(0);
        for (let i = 0; i < bufLen; i++) nData[i] = Math.random() * 2 - 1;

        const noise = ac.createBufferSource();
        noise.buffer = nBuf;
        const nf = ac.createBiquadFilter();
        nf.type = 'bandpass';
        nf.frequency.setValueAtTime(3000, t);
        nf.frequency.exponentialRampToValueAtTime(400, t + 0.12);
        nf.Q.value = 2;
        const ng = ac.createGain();
        ng.gain.setValueAtTime(0.08, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.12);

        noise.connect(nf);
        nf.connect(ng);
        send(ng);
        noise.start(t); noise.stop(t + 0.12);

        // Sub thump
        const sub = ac.createOscillator();
        sub.type = 'sine';
        sub.frequency.setValueAtTime(120, t);
        sub.frequency.exponentialRampToValueAtTime(50, t + 0.1);
        const subG = ac.createGain();
        subG.gain.setValueAtTime(0.12, t);
        subG.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
        sub.connect(subG);
        subG.connect(dryGain);
        sub.start(t); sub.stop(t + 0.1);
    }

    // ---- SOUND: Combo milestone ----
    function sndCombo(count) {
        if (!ac || muted) return;
        const t = ac.currentTime;
        const freq = 500 + Math.min(count, 30) * 25;

        const o = ac.createOscillator();
        o.type = 'sine';
        o.frequency.value = freq;
        const g = ac.createGain();
        g.gain.setValueAtTime(0.1, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        o.connect(g);
        send(g);
        o.start(t); o.stop(t + 0.15);

        // Harmonic fifth
        const o2 = ac.createOscillator();
        o2.type = 'triangle';
        o2.frequency.value = freq * 1.5;
        const g2 = ac.createGain();
        g2.gain.setValueAtTime(0.04, t + 0.03);
        g2.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
        o2.connect(g2);
        send(g2);
        o2.start(t + 0.03); o2.stop(t + 0.12);
    }

    // ---- SOUND: Combo tier milestone (fanfare) ----
    function sndComboTier(tierIndex) {
        if (!ac || muted) return;
        const t = ac.currentTime;
        // Rising chord — more notes for higher tiers
        const baseFreq = 400 + tierIndex * 80;
        const noteCount = 2 + tierIndex;
        for (let i = 0; i < noteCount; i++) {
            const delay = i * 0.06;
            const freq = baseFreq * Math.pow(1.25, i); // major third intervals
            const o = ac.createOscillator();
            o.type = 'sine';
            o.frequency.value = freq;
            const g = ac.createGain();
            g.gain.setValueAtTime(0.14 - i * 0.01, t + delay);
            g.gain.exponentialRampToValueAtTime(0.001, t + delay + 0.4);
            o.connect(g);
            send(g);
            o.start(t + delay); o.stop(t + delay + 0.4);
        }
        // Shimmer noise
        const bufLen = ac.sampleRate * 0.15;
        const nb = ac.createBuffer(1, bufLen, ac.sampleRate);
        const nd = nb.getChannelData(0);
        for (let i = 0; i < bufLen; i++) nd[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufLen, 2);
        const ns = ac.createBufferSource();
        ns.buffer = nb;
        const nf = ac.createBiquadFilter();
        nf.type = 'bandpass'; nf.frequency.value = 4000 + tierIndex * 1000; nf.Q.value = 2;
        const ng = ac.createGain();
        ng.gain.setValueAtTime(0.04, t); ng.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
        ns.connect(nf); nf.connect(ng); send(ng);
        ns.start(t); ns.stop(t + 0.15);
    }

    // ---- SOUND: Hurt ----
    function sndHurt() {
        if (!ac || muted) return;
        const t = ac.currentTime;

        // Distorted descending
        const o = ac.createOscillator();
        o.type = 'sawtooth';
        o.frequency.setValueAtTime(250, t);
        o.frequency.exponentialRampToValueAtTime(80, t + 0.2);
        const dist = ac.createWaveShaper();
        dist.curve = makeDistCurve(100);
        const g = ac.createGain();
        g.gain.setValueAtTime(0.12, t);
        g.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
        o.connect(dist);
        dist.connect(g);
        send(g);
        o.start(t); o.stop(t + 0.25);

        // Noise crunch
        const bufLen = ac.sampleRate * 0.08;
        const nb = ac.createBuffer(1, bufLen, ac.sampleRate);
        const nd = nb.getChannelData(0);
        for (let i = 0; i < bufLen; i++) nd[i] = Math.random() * 2 - 1;
        const ns = ac.createBufferSource();
        ns.buffer = nb;
        const ng = ac.createGain();
        ng.gain.setValueAtTime(0.1, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
        ns.connect(ng);
        ng.connect(dryGain);
        ns.start(t); ns.stop(t + 0.08);
    }

    // ---- SOUND: Death ----
    function sndDeath() {
        if (!ac || muted) return;
        const t = ac.currentTime;

        // Three descending impacts
        for (let i = 0; i < 4; i++) {
            const offset = i * 0.1;
            const o = ac.createOscillator();
            o.type = 'sawtooth';
            o.frequency.setValueAtTime(350 - i * 70, t + offset);
            o.frequency.exponentialRampToValueAtTime(30, t + offset + 0.35);
            const dist = ac.createWaveShaper();
            dist.curve = makeDistCurve(50);
            const g = ac.createGain();
            g.gain.setValueAtTime(0.13 - i * 0.02, t + offset);
            g.gain.exponentialRampToValueAtTime(0.001, t + offset + 0.35);
            o.connect(dist);
            dist.connect(g);
            send(g);
            o.start(t + offset); o.stop(t + offset + 0.35);
        }

        // Sub boom
        const sub = ac.createOscillator();
        sub.type = 'sine';
        sub.frequency.setValueAtTime(80, t);
        sub.frequency.exponentialRampToValueAtTime(20, t + 0.6);
        const sg = ac.createGain();
        sg.gain.setValueAtTime(0.25, t);
        sg.gain.exponentialRampToValueAtTime(0.001, t + 0.6);
        sub.connect(sg);
        sg.connect(dryGain);
        sub.start(t); sub.stop(t + 0.6);

        // Noise wash
        const bufLen = ac.sampleRate * 0.5;
        const nb = ac.createBuffer(2, bufLen, ac.sampleRate);
        for (let ch = 0; ch < 2; ch++) {
            const d = nb.getChannelData(ch);
            for (let i = 0; i < bufLen; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufLen, 3);
        }
        const ns = ac.createBufferSource();
        ns.buffer = nb;
        const nf = ac.createBiquadFilter();
        nf.type = 'lowpass';
        nf.frequency.setValueAtTime(2000, t);
        nf.frequency.exponentialRampToValueAtTime(200, t + 0.5);
        const ng = ac.createGain();
        ng.gain.setValueAtTime(0.08, t);
        ng.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
        ns.connect(nf);
        nf.connect(ng);
        send(ng);
        ns.start(t); ns.stop(t + 0.5);
    }

    // ---- SOUND: Level up (arpeggiated chime) ----
    function sndLevelUp() {
        if (!ac || muted) return;
        const t = ac.currentTime;
        const notes = [523.25, 659.25, 783.99, 1046.50, 1318.51];

        notes.forEach((freq, i) => {
            const delay = i * 0.07;
            const o = ac.createOscillator();
            o.type = 'sine';
            o.frequency.value = freq;
            const g = ac.createGain();
            g.gain.setValueAtTime(0.12 - i * 0.015, t + delay);
            g.gain.exponentialRampToValueAtTime(0.001, t + delay + 0.35);
            o.connect(g);
            send(g);
            o.start(t + delay); o.stop(t + delay + 0.35);

            // Bell harmonic
            const o2 = ac.createOscillator();
            o2.type = 'sine';
            o2.frequency.value = freq * 2.756; // inharmonic bell
            const g2 = ac.createGain();
            g2.gain.setValueAtTime(0.03, t + delay);
            g2.gain.exponentialRampToValueAtTime(0.001, t + delay + 0.2);
            o2.connect(g2);
            send(g2);
            o2.start(t + delay); o2.stop(t + delay + 0.2);
        });
    }

    // ---- SOUND: Heartbeat (low timer warning) ----
    let heartbeatInterval = null;

    function startHeartbeat() {
        if (heartbeatInterval || !ac || muted) return;
        heartbeatInterval = setInterval(() => {
            if (!ac || muted || !gameRunning) { stopHeartbeat(); return; }
            const elapsed = performance.now() - cycleStart;
            const pct = 1 - elapsed / cycleTime;
            if (pct > 0.3) return;

            const t = ac.currentTime;
            // Double thump
            for (let i = 0; i < 2; i++) {
                const o = ac.createOscillator();
                o.type = 'sine';
                o.frequency.setValueAtTime(55, t + i * 0.12);
                o.frequency.exponentialRampToValueAtTime(35, t + i * 0.12 + 0.1);
                const g = ac.createGain();
                const vol = (0.15 - pct * 0.3) * (i === 0 ? 1 : 0.6);
                g.gain.setValueAtTime(Math.max(0.02, vol), t + i * 0.12);
                g.gain.exponentialRampToValueAtTime(0.001, t + i * 0.12 + 0.1);
                o.connect(g);
                g.connect(dryGain);
                o.start(t + i * 0.12); o.stop(t + i * 0.12 + 0.1);
            }
        }, 400);
    }

    function stopHeartbeat() {
        if (heartbeatInterval) { clearInterval(heartbeatInterval); heartbeatInterval = null; }
    }

    // ---- AMBIENT DRONE ----
    let droneNodes = [];

    function startDrone() {
        if (!ac || muted || droneNodes.length > 0) return;

        // Layer 1: deep sub
        const o1 = ac.createOscillator();
        o1.type = 'sine';
        o1.frequency.value = 40;
        const g1 = ac.createGain();
        g1.gain.value = 0.04;
        // Slow LFO on volume
        const lfo1 = ac.createOscillator();
        lfo1.frequency.value = 0.08;
        const lfoG1 = ac.createGain();
        lfoG1.gain.value = 0.015;
        lfo1.connect(lfoG1);
        lfoG1.connect(g1.gain);
        o1.connect(g1);
        g1.connect(dryGain);
        o1.start(); lfo1.start();
        droneNodes.push(o1, lfo1);

        // Layer 2: filtered pad
        const o2 = ac.createOscillator();
        o2.type = 'triangle';
        o2.frequency.value = 110;
        const f2 = ac.createBiquadFilter();
        f2.type = 'lowpass';
        f2.frequency.value = 180;
        f2.Q.value = 3;
        // LFO on filter
        const lfo2 = ac.createOscillator();
        lfo2.frequency.value = 0.05;
        const lfoG2 = ac.createGain();
        lfoG2.gain.value = 60;
        lfo2.connect(lfoG2);
        lfoG2.connect(f2.frequency);
        const g2 = ac.createGain();
        g2.gain.value = 0.025;
        o2.connect(f2);
        f2.connect(g2);
        send(g2);
        o2.start(); lfo2.start();
        droneNodes.push(o2, lfo2);

        // Layer 3: high shimmer
        const o3 = ac.createOscillator();
        o3.type = 'sine';
        o3.frequency.value = 880;
        const g3 = ac.createGain();
        g3.gain.value = 0.008;
        const lfo3 = ac.createOscillator();
        lfo3.frequency.value = 0.12;
        const lfoG3 = ac.createGain();
        lfoG3.gain.value = 0.005;
        lfo3.connect(lfoG3);
        lfoG3.connect(g3.gain);
        o3.connect(g3);
        send(g3);
        o3.start(); lfo3.start();
        droneNodes.push(o3, lfo3);
    }

    function stopDrone() {
        droneNodes.forEach(n => { try { n.stop(); } catch(e) {} });
        droneNodes = [];
    }

    function makeDistCurve(amount) {
        const samples = 256;
        const curve = new Float32Array(samples);
        for (let i = 0; i < samples; i++) {
            const x = (i * 2) / samples - 1;
            curve[i] = ((Math.PI + amount) * x) / (Math.PI + amount * Math.abs(x));
        }
        return curve;
    }

    // Volume toggle
    const volBtn = document.getElementById('vol-btn');
    volBtn.addEventListener('click', () => {
        initAudio();
        muted = !muted;
        volBtn.textContent = muted ? '✕' : '♫';
        volBtn.style.color = muted ? '#ff6b6b' : '#333';
        if (muted) { stopDrone(); stopHeartbeat(); }
        else if (gameRunning) { startDrone(); startHeartbeat(); }
    });

    // ============================================================
    //  GAME CONFIG
    // ============================================================
    // Responsive cell size: smaller on mobile for wider view
    const isMobile = window.innerWidth < 768 || matchMedia('(pointer:coarse)').matches;
    const CELL = isMobile ? Math.max(36, Math.floor(window.innerWidth / 10)) : 58;
    const GAP = isMobile ? 3 : 5;
    const STRIDE = CELL + GAP;
    const CELL_R = isMobile ? 7 : 10;  // border radius scales with cell
    const VIEW_PAD = 7;

    const COLORS = ['#ff6b6b','#ffd93d','#6bcb77','#4d96ff','#e056a0','#ff9f43'];

    const BASE_CYCLE = 2400;   // more generous start
    const MIN_CYCLE  = 700;    // floor slightly higher
    const CYCLE_DEC  = 40;     // gentler ramp (was 55)

    // Combo milestone thresholds & multipliers
    const COMBO_TIERS = [
        { at: 5,  label: 'GOOD',         mult: 1.5, color: '#6bcb77' },
        { at: 10, label: 'GREAT',        mult: 2.0, color: '#4d96ff' },
        { at: 20, label: 'FIRE',         mult: 3.0, color: '#ff9f43' },
        { at: 35, label: 'UNSTOPPABLE',  mult: 4.0, color: '#e056a0' },
        { at: 50, label: 'LEGENDARY',    mult: 5.0, color: '#ffd93d' },
    ];

    // ============================================================
    //  STATE
    // ============================================================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    let W, H, dpr;
    let camX = 0, camY = 0, camTargetX = 0, camTargetY = 0;
    let playerGX = 0, playerGY = 0;
    let playerColor = 0;
    let nextColors = [];
    let score = 0, level = 1, lives = 3;
    let bestScore = parseInt(localStorage.getItem('cs3_best') || '0');
    let gameRunning = false;
    let availableColors = 3;
    let cycleTime = BASE_CYCLE, cycleStart = 0;
    let moveCount = 0, combo = 0, maxCombo = 0;
    let hintVisible = true;
    let gameTime = 0; // total seconds played

    const cellMap = new Map();
    const trail = new Set();

    // Visual state
    let dying = false, deathTime = 0, deathX = 0, deathY = 0;
    let particles = [];
    let floatingTexts = [];
    let screenFlash = 0, screenFlashColor = '#fff';
    let playerScale = 1, playerScaleTarget = 1, playerAngle = 0;
    let playerBreath = 0; // idle breathing

    // Camera shake
    let shakeX = 0, shakeY = 0, shakeDecay = 0;

    // DOM
    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level-display');
    const comboText = document.getElementById('combo-text');
    const colorCenter = document.getElementById('color-center');
    const timerArc = document.getElementById('timer-arc');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over');
    const finalScoreEl = document.getElementById('final-score');
    const bestScoreTextEl = document.getElementById('best-score-text');
    const deathMsgEl = document.getElementById('death-msg');
    const newBestEl = document.getElementById('new-best');
    const hintEl = document.getElementById('hint-text');
    const levelFlash = document.getElementById('level-flash');
    const levelUpText = document.getElementById('level-up-text');
    const newColorText = document.getElementById('new-color-text');
    const comboTierText = document.getElementById('combo-tier-text');
    const comboMultiplier = document.getElementById('combo-multiplier');
    const leaderboardEl = document.getElementById('leaderboard');
    const nameInputRow = document.getElementById('name-input-row');
    const playerNameInput = document.getElementById('player-name');

    // ============================================================
    //  LEADERBOARD (localStorage)
    // ============================================================
    const LB_KEY = 'cs3_leaderboard';
    const LB_MAX = 10;

    function getLeaderboard() {
        try { return JSON.parse(localStorage.getItem(LB_KEY)) || []; }
        catch { return []; }
    }

    function saveToLeaderboard(name, sc, lvl, mc) {
        const lb = getLeaderboard();
        lb.push({ name: name || 'AAA', score: sc, level: lvl, maxCombo: mc, date: Date.now() });
        lb.sort((a, b) => b.score - a.score);
        if (lb.length > LB_MAX) lb.length = LB_MAX;
        localStorage.setItem(LB_KEY, JSON.stringify(lb));
        return lb;
    }

    function renderLeaderboard(currentScore) {
        const lb = getLeaderboard();
        if (lb.length === 0) { leaderboardEl.style.display = 'none'; return; }
        leaderboardEl.style.display = 'block';
        let html = '<h3>Classifica</h3>';
        lb.forEach((e, i) => {
            const rankClass = i === 0 ? 'gold' : i === 1 ? 'silver' : i === 2 ? 'bronze' : '';
            const isCurrent = (e.score === currentScore && e.date && Date.now() - e.date < 3000);
            html += `<div class="lb-row${isCurrent ? ' current' : ''}">
                <span class="lb-rank ${rankClass}">${i + 1}</span>
                <span class="lb-name">${escHtml(e.name)}</span>
                <span class="lb-score">${e.score}</span>
                <span class="lb-level">Lv.${e.level}</span>
            </div>`;
        });
        leaderboardEl.innerHTML = html;
    }

    function isLeaderboardWorthy(sc) {
        const lb = getLeaderboard();
        return lb.length < LB_MAX || sc > (lb[lb.length - 1]?.score || 0);
    }

    function escHtml(s) {
        return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
    }

    // Restore last used name
    let lastPlayerName = localStorage.getItem('cs3_name') || '';

    // ============================================================
    //  RESIZE
    // ============================================================
    function resize() {
        dpr = window.devicePixelRatio || 1;
        W = window.innerWidth; H = window.innerHeight;
        canvas.width = W * dpr; canvas.height = H * dpr;
        canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    // ============================================================
    //  GRID — Clustered color generation
    // ============================================================
    //
    // Instead of pure random (which creates 48% dead-ends at 6 colors),
    // we use Perlin-like noise to create organic "rivers" of color.
    // Each color forms navigable paths across the grid.
    // Cluster size shrinks as colors increase, keeping difficulty scaling.

    function getCellColor(gx, gy) {
        const key = gx + ',' + gy;
        if (cellMap.has(key)) return cellMap.get(key);
        const c = generateClusteredColor(gx, gy);
        cellMap.set(key, c);
        return c;
    }

    function generateClusteredColor(gx, gy) {
        // Multi-octave value noise sampled at different scales per color.
        // Each color gets its own noise field; highest value wins.
        // Scale tuned so clusters are small enough to create frequent
        // borders (multiple colors accessible) but big enough to form
        // navigable paths. Stats at this scale:
        //   3 colors: 64% move chance, 2% dead-ends, ~1.6 cycle wait
        //   6 colors: 44% move chance, 11% dead-ends, ~2.3 cycle wait
        let bestColor = 0;
        let bestVal = -Infinity;

        for (let c = 0; c < availableColors; c++) {
            const offsetX = c * 1000.7;
            const offsetY = c * 2000.3;

            const scale1 = 0.35 + (availableColors - 3) * 0.03;
            const scale2 = scale1 * 2.0;

            const n1 = valueNoise((gx + offsetX) * scale1, (gy + offsetY) * scale1);
            const n2 = valueNoise((gx + offsetX) * scale2, (gy + offsetY) * scale2) * 0.5;

            const val = n1 + n2;
            if (val > bestVal) {
                bestVal = val;
                bestColor = c;
            }
        }

        return bestColor;
    }

    // Smooth value noise (integer-lattice interpolated)
    function valueNoise(x, y) {
        const ix = Math.floor(x), iy = Math.floor(y);
        const fx = x - ix, fy = y - iy;

        // Smooth interpolation (quintic)
        const sx = fx * fx * fx * (fx * (fx * 6 - 15) + 10);
        const sy = fy * fy * fy * (fy * (fy * 6 - 15) + 10);

        const v00 = hashFloat(ix, iy);
        const v10 = hashFloat(ix + 1, iy);
        const v01 = hashFloat(ix, iy + 1);
        const v11 = hashFloat(ix + 1, iy + 1);

        const top = v00 + (v10 - v00) * sx;
        const bot = v01 + (v11 - v01) * sx;
        return top + (bot - top) * sy;
    }

    // Deterministic hash → float [0,1]
    function hashFloat(x, y) {
        let h = (x * 374761393 + y * 668265263) ^ 0x55555555;
        h = Math.imul(h ^ (h >>> 13), 1274126177);
        h = h ^ (h >>> 16);
        return (Math.abs(h) % 100000) / 100000;
    }

    // Legacy hash still used for non-grid things
    function hash(x, y) {
        let h = (x * 374761393 + y * 668265263) ^ 0x55555555;
        h = Math.imul(h ^ (h >>> 13), 1274126177);
        h = h ^ (h >>> 16);
        return Math.abs(h);
    }

    function regenerateCells() { cellMap.clear(); }

    // ============================================================
    //  PLAYER COLOR
    // ============================================================
    function genNextColors() {
        nextColors = [];
        for (let i = 0; i < 3; i++) {
            let c;
            do { c = Math.floor(Math.random() * availableColors); }
            while (c === (nextColors.length > 0 ? nextColors[nextColors.length - 1] : playerColor));
            nextColors.push(c);
        }
        updateNextUI();
    }

    function cyclePlayerColor() {
        if (!nextColors.length) genNextColors();
        playerColor = nextColors.shift();
        nextColors.push(rndColorExcl(nextColors[nextColors.length - 1]));
        cycleStart = performance.now();
        updateColorUI();
        updateNextUI();
        sndColorChange();
        colorCenter.classList.add('pulse');
        setTimeout(() => colorCenter.classList.remove('pulse'), 300);
        playerScaleTarget = 1.1;
        setTimeout(() => { playerScaleTarget = 1; }, 100);
    }

    function rndColorExcl(excl) {
        let c; do { c = Math.floor(Math.random() * availableColors); } while (c === excl); return c;
    }

    function updateColorUI() {
        colorCenter.style.backgroundColor = COLORS[playerColor];
        colorCenter.style.boxShadow = `0 0 28px ${COLORS[playerColor]}55`;
    }

    function updateNextUI() {
        for (let i = 0; i < 3; i++) {
            const el = document.getElementById('next' + (i + 1));
            if (nextColors[i] !== undefined) el.style.backgroundColor = COLORS[nextColors[i]];
        }
    }

    function updateLivesUI() {
        for (let i = 1; i <= 3; i++)
            document.getElementById('life' + i).classList.toggle('lost', i > lives);
    }

    // ============================================================
    //  CAMERA
    // ============================================================
    function updateCamera(dt) {
        camTargetX = playerGX * STRIDE;
        camTargetY = playerGY * STRIDE;
        const lerp = 1 - Math.pow(0.0006, dt);
        camX += (camTargetX - camX) * lerp;
        camY += (camTargetY - camY) * lerp;

        // Shake decay
        if (shakeDecay > 0) {
            shakeDecay -= dt * 8;
            const intensity = Math.max(0, shakeDecay) * 6;
            shakeX = (Math.random() - 0.5) * intensity;
            shakeY = (Math.random() - 0.5) * intensity;
        } else {
            shakeX = 0; shakeY = 0;
        }
    }

    // ============================================================
    //  PARTICLES & FLOAT TEXT
    // ============================================================
    function spawnP(wx, wy, color, count, spread) {
        spread = spread || 1;
        for (let i = 0; i < count; i++) {
            const a = Math.random() * Math.PI * 2;
            const spd = (25 + Math.random() * 90) * spread;
            particles.push({
                x: wx, y: wy,
                vx: Math.cos(a) * spd, vy: Math.sin(a) * spd,
                life: 0.25 + Math.random() * 0.45,
                maxLife: 0.25 + Math.random() * 0.45,
                size: 1.5 + Math.random() * 3.5,
                color,
            });
        }
    }

    function spawnTrailP(wx, wy, color) {
        for (let i = 0; i < 4; i++) {
            particles.push({
                x: wx + (Math.random() - 0.5) * CELL * 0.5,
                y: wy + (Math.random() - 0.5) * CELL * 0.5,
                vx: (Math.random() - 0.5) * 12,
                vy: -8 - Math.random() * 18,
                life: 0.25 + Math.random() * 0.25,
                maxLife: 0.25 + Math.random() * 0.25,
                size: 1.5 + Math.random() * 2,
                color,
            });
        }
    }

    function updateParticles(dt) {
        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx * dt; p.y += p.vy * dt;
            p.vx *= 0.94; p.vy *= 0.94;
            p.life -= dt;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function spawnFloat(text, wx, wy, color) {
        floatingTexts.push({ text, x: wx, y: wy, color, life: 0.9, maxLife: 0.9, vy: -55 });
    }

    function updateFloats(dt) {
        for (let i = floatingTexts.length - 1; i >= 0; i--) {
            const f = floatingTexts[i];
            f.y += f.vy * dt; f.vy *= 0.97; f.life -= dt;
            if (f.life <= 0) floatingTexts.splice(i, 1);
        }
    }

    // ============================================================
    //  RENDER
    // ============================================================
    function render(now) {
        ctx.clearRect(0, 0, W, H);

        const ox = W / 2 - camX + shakeX;
        const oy = H / 2 - camY + shakeY;

        const minGX = Math.floor((camX - W / 2) / STRIDE) - VIEW_PAD;
        const maxGX = Math.ceil((camX + W / 2) / STRIDE) + VIEW_PAD;
        const minGY = Math.floor((camY - H / 2) / STRIDE) - VIEW_PAD;
        const maxGY = Math.ceil((camY + H / 2) / STRIDE) + VIEW_PAD;

        const vigR = Math.min(W, H) * 0.58;

        // --- CELLS ---
        for (let gy = minGY; gy <= maxGY; gy++) {
            for (let gx = minGX; gx <= maxGX; gx++) {
                const sx = gx * STRIDE + ox;
                const sy = gy * STRIDE + oy;
                if (sx + CELL < -10 || sx > W + 10 || sy + CELL < -10 || sy > H + 10) continue;
                if (gx === playerGX && gy === playerGY && !dying) continue; // draw player later

                const cellColor = getCellColor(gx, gy);
                const isTrail = trail.has(gx + ',' + gy);

                const dx = gx - playerGX, dy = gy - playerGY;
                const dist = Math.sqrt(dx * dx + dy * dy);

                const revealR = isMobile ? 5.5 : 4.8;
                const reveal = Math.max(0, 1 - dist / revealR);
                const reveal3 = reveal * reveal * reveal;

                // Vignette
                const scx = sx + CELL / 2 - W / 2, scy = sy + CELL / 2 - H / 2;
                const sDist = Math.sqrt(scx * scx + scy * scy);
                const vig = Math.max(0.1, 1 - Math.pow(sDist / vigR, 2));

                if (isTrail) {
                    const a = (0.06 + reveal3 * 0.14) * vig;
                    ctx.fillStyle = hexA(COLORS[cellColor], a);
                    rr(ctx, sx, sy, CELL, CELL, CELL_R); ctx.fill();
                    if (reveal3 > 0.15) {
                        ctx.strokeStyle = hexA(COLORS[cellColor], 0.06 * reveal3);
                        ctx.lineWidth = 1;
                        rr(ctx, sx, sy, CELL, CELL, CELL_R); ctx.stroke();
                    }
                } else {
                    const checker = ((gx + gy) % 2 === 0);
                    const base = checker ? 17 : 11;
                    const rgb = hex2rgb(COLORS[cellColor]);
                    const blend = reveal3 * 0.6;
                    const r = Math.round((base + (rgb.r - base) * blend) * vig);
                    const g = Math.round((base + (rgb.g - base) * blend) * vig);
                    const b = Math.round((base + (rgb.b - base) * blend) * vig);
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    rr(ctx, sx, sy, CELL, CELL, CELL_R); ctx.fill();

                    // Matching-color cells glow hint
                    if (cellColor === playerColor && reveal3 > 0.2 && dist < 2.8) {
                        const glowA = 0.08 * reveal3;
                        ctx.fillStyle = hexA(COLORS[cellColor], glowA);
                        rr(ctx, sx - 3, sy - 3, CELL + 6, CELL + 6, CELL_R + 3); ctx.fill();
                    }
                }
            }
        }

        // --- PLAYER ---
        if (!dying) {
            const psx = playerGX * STRIDE + ox;
            const psy = playerGY * STRIDE + oy;
            const pcx = psx + CELL / 2;
            const pcy = psy + CELL / 2;
            const s = playerScale + Math.sin(playerBreath) * 0.015;
            const c = COLORS[playerColor];

            ctx.save();
            ctx.translate(pcx, pcy);
            ctx.scale(s, s);
            ctx.rotate(playerAngle);

            // Outer glow (double layer)
            ctx.shadowColor = c;
            ctx.shadowBlur = isMobile ? 22 : 35;
            ctx.fillStyle = c;
            rr(ctx, -CELL / 2, -CELL / 2, CELL, CELL, CELL_R + 1); ctx.fill();
            ctx.shadowBlur = 15;
            rr(ctx, -CELL / 2, -CELL / 2, CELL, CELL, CELL_R + 1); ctx.fill();
            ctx.shadowBlur = 0;

            // Gradient body
            const grad = ctx.createLinearGradient(-CELL / 2, -CELL / 2, CELL / 2, CELL / 2);
            const rgbC = hex2rgb(c);
            grad.addColorStop(0, `rgba(${Math.min(255, rgbC.r + 40)},${Math.min(255, rgbC.g + 40)},${Math.min(255, rgbC.b + 40)},1)`);
            grad.addColorStop(1, `rgba(${Math.max(0, rgbC.r - 30)},${Math.max(0, rgbC.g - 30)},${Math.max(0, rgbC.b - 30)},1)`);
            ctx.fillStyle = grad;
            rr(ctx, -CELL / 2, -CELL / 2, CELL, CELL, CELL_R + 1); ctx.fill();

            // Shine
            const shine = ctx.createLinearGradient(-CELL / 2, -CELL / 2, CELL / 4, CELL / 4);
            shine.addColorStop(0, 'rgba(255,255,255,0.18)');
            shine.addColorStop(0.5, 'rgba(255,255,255,0.02)');
            shine.addColorStop(1, 'rgba(0,0,0,0.08)');
            ctx.fillStyle = shine;
            rr(ctx, -CELL / 2, -CELL / 2, CELL, CELL, CELL_R + 1); ctx.fill();

            // Inner border
            ctx.strokeStyle = 'rgba(255,255,255,0.3)';
            ctx.lineWidth = 1.5;
            rr(ctx, -CELL / 2 + 4, -CELL / 2 + 4, CELL - 8, CELL - 8, CELL_R - 3); ctx.stroke();

            ctx.restore();
        }

        // --- PARTICLES ---
        for (const p of particles) {
            const sx = p.x + ox, sy = p.y + oy;
            const a = p.life / p.maxLife;
            ctx.globalAlpha = a * a;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(sx, sy, p.size * (0.3 + a * 0.7), 0, Math.PI * 2);
            ctx.fill();
        }
        ctx.globalAlpha = 1;

        // --- FLOATING TEXTS ---
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        for (const ft of floatingTexts) {
            const sx = ft.x + ox, sy = ft.y + oy;
            const a = ft.life / ft.maxLife;
            ctx.globalAlpha = a;
            ctx.font = `bold 15px 'SF Mono', 'Fira Code', monospace`;
            ctx.fillStyle = ft.color;
            ctx.shadowColor = ft.color;
            ctx.shadowBlur = 10;
            ctx.fillText(ft.text, sx, sy);
            ctx.shadowBlur = 0;
        }
        ctx.globalAlpha = 1;

        // --- DEATH SHOCKWAVE ---
        if (dying) {
            const el = (now - deathTime) / 1000;
            const sx = deathX * STRIDE + ox + CELL / 2;
            const sy = deathY * STRIDE + oy + CELL / 2;
            for (let r = 0; r < 4; r++) {
                const rad = el * 350 - r * 25;
                const a = Math.max(0, 1 - el * 1.8) * (1 - r * 0.2);
                if (rad > 0 && a > 0) {
                    ctx.beginPath();
                    ctx.arc(sx, sy, rad, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(255,34,68,${a})`;
                    ctx.lineWidth = 3 - r * 0.5;
                    ctx.stroke();
                }
            }
        }

        // --- SCREEN FLASH ---
        if (screenFlash > 0) {
            ctx.fillStyle = hexA(screenFlashColor, screenFlash * 0.12);
            ctx.fillRect(0, 0, W, H);
        }

        // --- TIMER ARC ---
        if (gameRunning) {
            const el = now - cycleStart;
            const pct = Math.max(0, 1 - el / cycleTime);
            const circ = 213.63;
            timerArc.setAttribute('stroke-dashoffset', ((1 - pct) * circ).toString());

            if (pct > 0.3) {
                timerArc.setAttribute('stroke', COLORS[playerColor]);
            } else {
                const pulse = 0.5 + Math.sin(now * 0.015) * 0.3;
                timerArc.setAttribute('stroke', hexA('#ff6b6b', 0.4 + pulse));
            }
        }
    }

    function rr(ctx, x, y, w, h, r) {
        ctx.beginPath();
        ctx.moveTo(x + r, y);
        ctx.lineTo(x + w - r, y); ctx.quadraticCurveTo(x + w, y, x + w, y + r);
        ctx.lineTo(x + w, y + h - r); ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
        ctx.lineTo(x + r, y + h); ctx.quadraticCurveTo(x, y + h, x, y + h - r);
        ctx.lineTo(x, y + r); ctx.quadraticCurveTo(x, y, x + r, y);
        ctx.closePath();
    }

    function hex2rgb(hex) {
        return { r: parseInt(hex.slice(1,3),16), g: parseInt(hex.slice(3,5),16), b: parseInt(hex.slice(5,7),16) };
    }

    function hexA(hex, a) {
        const {r,g,b} = hex2rgb(hex);
        return `rgba(${r},${g},${b},${Math.max(0,Math.min(1,a))})`;
    }

    // ============================================================
    //  GAME LOOP
    // ============================================================
    let lastTime = 0;

    function loop(now) {
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;

        if (gameRunning && !dying) {
            gameTime += dt;
            if (now - cycleStart >= cycleTime) cyclePlayerColor();
        }

        updateCamera(dt);
        updateParticles(dt);
        updateFloats(dt);

        playerScale += (playerScaleTarget - playerScale) * Math.min(1, dt * 16);
        playerAngle *= Math.pow(0.0001, dt);
        playerBreath += dt * 2.2;

        if (screenFlash > 0) screenFlash = Math.max(0, screenFlash - dt * 5);

        render(now);
        requestAnimationFrame(loop);
    }

    // ============================================================
    //  MOVEMENT
    // ============================================================
    let lastMoveTime = 0;
    const MOVE_COOLDOWN = 60; // ms between moves

    function move(dir) {
        if (!gameRunning || dying) return;

        const now = performance.now();
        if (now - lastMoveTime < MOVE_COOLDOWN) return;
        lastMoveTime = now;

        if (hintVisible) { hintVisible = false; hintEl.style.opacity = '0'; }

        let nx = playerGX, ny = playerGY;
        switch (dir) {
            case 'right': nx++; break;
            case 'left':  nx--; break;
            case 'down':  ny++; break;
            case 'up':    ny--; break;
        }

        const targetColor = getCellColor(nx, ny);

        if (targetColor !== playerColor) {
            hurt(nx, ny);
            return;
        }

        // --- VALID MOVE ---
        const destKey = nx + ',' + ny;
        const isNewCell = !trail.has(destKey);

        trail.add(playerGX + ',' + playerGY);
        playerGX = nx; playerGY = ny;
        moveCount++;

        if (isNewCell) {
            // Only score & combo on NEW cells
            combo++;
            if (combo > maxCombo) maxCombo = combo;

            // Determine current combo tier multiplier
            let currentMult = 1;
            let currentTierIdx = -1;
            for (let t = COMBO_TIERS.length - 1; t >= 0; t--) {
                if (combo >= COMBO_TIERS[t].at) {
                    currentMult = COMBO_TIERS[t].mult;
                    currentTierIdx = t;
                    break;
                }
            }

            // Base score + time bonus, then apply multiplier
            const elapsed = performance.now() - cycleStart;
            const timeBonus = Math.max(0, Math.floor((1 - elapsed / cycleTime) * 5));
            const basePts = 1 + timeBonus;
            const pts = Math.round(basePts * currentMult);
            score += pts;
            scoreEl.textContent = score;
            scoreEl.classList.add('bump');
            setTimeout(() => scoreEl.classList.remove('bump'), 80);

            // Float text
            const wx2 = playerGX * STRIDE + CELL / 2;
            const wy2 = playerGY * STRIDE + CELL / 2;
            const floatColor = currentTierIdx >= 0 ? COMBO_TIERS[currentTierIdx].color : COLORS[playerColor];
            if (pts > 1) spawnFloat('+' + pts, wx2, wy2 - CELL / 2, floatColor);

            // Check if we just crossed a combo tier threshold
            for (let t = 0; t < COMBO_TIERS.length; t++) {
                if (combo === COMBO_TIERS[t].at) {
                    // Tier milestone reached!
                    const tier = COMBO_TIERS[t];
                    comboTierText.textContent = tier.label;
                    comboTierText.style.color = tier.color;
                    comboTierText.style.textShadow = `0 0 40px ${tier.color}66`;
                    comboTierText.style.fontSize = (24 + t * 4) + 'px';
                    comboTierText.classList.remove('show');
                    void comboTierText.offsetWidth; // reflow
                    comboTierText.classList.add('show');

                    comboMultiplier.textContent = 'x' + tier.mult + ' PUNTI';
                    comboMultiplier.style.color = tier.color;
                    comboMultiplier.classList.remove('show');
                    void comboMultiplier.offsetWidth;
                    comboMultiplier.classList.add('show');

                    setTimeout(() => {
                        comboTierText.classList.remove('show');
                        comboMultiplier.classList.remove('show');
                    }, 1400);

                    sndComboTier(t);
                    screenFlash = 0.6;
                    screenFlashColor = tier.color;
                    spawnP(wx2, wy2, tier.color, 15 + t * 5, 1.2);
                    break;
                }
            }

            // Combo counter UI (always shows current streak)
            if (combo >= 3) {
                const tierLabel = currentTierIdx >= 0 ? COMBO_TIERS[currentTierIdx].label + ' ' : '';
                comboText.textContent = tierLabel + 'x' + combo;
                comboText.style.color = currentTierIdx >= 0 ? COMBO_TIERS[currentTierIdx].color : '#ffd93d';
                comboText.classList.add('visible');
                comboText.classList.add('pop');
                setTimeout(() => comboText.classList.remove('pop'), 120);
            } else {
                comboText.classList.remove('visible');
            }
        } else {
            // Revisiting a cell — reset combo, no points
            if (combo > 0) {
                combo = 0;
                comboText.classList.remove('visible');
            }
        }

        // Squash/stretch
        if (dir === 'left' || dir === 'right') {
            playerScaleTarget = 1.07;
            playerAngle = dir === 'right' ? 0.05 : -0.05;
        } else {
            playerScaleTarget = 1.07;
            playerAngle = dir === 'down' ? 0.04 : -0.04;
        }
        setTimeout(() => { playerScaleTarget = 1; }, 70);

        // FX — always play move sound & trail particles
        const wx = playerGX * STRIDE + CELL / 2;
        const wy = playerGY * STRIDE + CELL / 2;
        spawnTrailP(wx, wy, COLORS[playerColor]);
        sndMove(playerColor, dir);

        // Level up
        const newLvl = Math.floor(moveCount / 20) + 1;
        if (newLvl > level) {
            level = newLvl;
            levelEl.textContent = 'Level ' + level;
            cycleTime = Math.max(MIN_CYCLE, BASE_CYCLE - (level - 1) * CYCLE_DEC);

            const newAvail = Math.min(COLORS.length, 3 + Math.floor((level - 1) / 2));
            if (newAvail > availableColors) {
                availableColors = newAvail;
                regenerateCells();
                cellMap.set(playerGX + ',' + playerGY, playerColor);
                genNextColors();

                // Speed spike when new color added (gentler: -80ms instead of -120)
                cycleTime = Math.max(MIN_CYCLE, cycleTime - 80);

                // Announce new color
                newColorText.textContent = '+1 COLORE — ' + availableColors + ' COLORI';
                newColorText.style.color = COLORS[availableColors - 1];
                newColorText.style.textShadow = `0 0 30px ${COLORS[availableColors - 1]}44`;
                newColorText.classList.add('show');
                setTimeout(() => newColorText.classList.remove('show'), 1500);
            }

            sndLevelUp();
            screenFlash = 1; screenFlashColor = '#ffd93d';
            levelFlash.classList.add('active');
            levelUpText.textContent = 'LEVEL ' + level;
            levelUpText.classList.add('show');
            setTimeout(() => { levelFlash.classList.remove('active'); levelUpText.classList.remove('show'); }, 1200);
        }
    }

    function hurt(tx, ty) {
        lives--; combo = 0;
        comboText.classList.remove('visible');
        updateLivesUI();

        shakeDecay = 1;
        screenFlash = 1; screenFlashColor = '#ff2244';

        const wx = tx * STRIDE + CELL / 2;
        const wy = ty * STRIDE + CELL / 2;
        spawnP(wx, wy, '#ff2244', 14, 0.8);
        spawnFloat('MISS', wx, wy - CELL / 2, '#ff6b6b');

        if (lives <= 0) {
            die(tx, ty);
        } else {
            sndHurt();
            playerScaleTarget = 0.65;
            setTimeout(() => { playerScaleTarget = 1; }, 200);
        }
    }

    function die(tx, ty) {
        dying = true;
        deathTime = performance.now();
        deathX = tx; deathY = ty;

        sndDeath();
        stopDrone();
        stopHeartbeat();

        const wx = tx * STRIDE + CELL / 2;
        const wy = ty * STRIDE + CELL / 2;
        spawnP(wx, wy, '#ff2244', 50, 1.8);
        spawnP(wx, wy, COLORS[playerColor], 25, 1.3);
        spawnP(wx, wy, '#ffffff', 12, 1);

        shakeDecay = 2;

        setTimeout(() => {
            gameRunning = false; dying = false;

            const isNew = score > bestScore;
            if (isNew) { bestScore = score; localStorage.setItem('cs3_best', bestScore); }

            finalScoreEl.textContent = score;
            finalScoreEl.style.color = COLORS[playerColor];
            bestScoreTextEl.textContent = 'Best: ' + bestScore;
            newBestEl.style.display = isNew ? 'block' : 'none';
            deathMsgEl.textContent = 'Colore sbagliato!';
            document.getElementById('stat-moves').textContent = moveCount;
            document.getElementById('stat-level').textContent = level;
            document.getElementById('stat-combo').textContent = maxCombo;

            // Find best multiplier reached
            let bestMult = 1;
            for (let t = COMBO_TIERS.length - 1; t >= 0; t--) {
                if (maxCombo >= COMBO_TIERS[t].at) { bestMult = COMBO_TIERS[t].mult; break; }
            }
            document.getElementById('stat-mult').textContent = 'x' + bestMult;

            // Show name input if leaderboard-worthy
            if (isLeaderboardWorthy(score) && score > 0) {
                nameInputRow.style.display = 'flex';
                playerNameInput.value = lastPlayerName;
                // Wait a tick so overlay is visible, then focus
                setTimeout(() => playerNameInput.focus(), 100);
            } else {
                nameInputRow.style.display = 'none';
            }

            renderLeaderboard(-1); // show existing
            gameOverScreen.style.display = 'flex';
        }, 1000);
    }

    // ============================================================
    //  START / RESTART
    // ============================================================
    function saveScoreIfNeeded() {
        // Save to leaderboard if name was entered
        const name = playerNameInput.value.trim();
        if (name && score > 0 && isLeaderboardWorthy(score)) {
            lastPlayerName = name;
            localStorage.setItem('cs3_name', name);
            saveToLeaderboard(name, score, level, maxCombo);
        }
    }

    function startGame() {
        saveScoreIfNeeded();
        initAudio();
        score = 0; level = 1; lives = 3; moveCount = 0;
        combo = 0; maxCombo = 0; availableColors = 3;
        cycleTime = BASE_CYCLE; gameTime = 0;
        playerGX = 0; playerGY = 0; playerColor = 0;
        camX = 0; camY = 0; camTargetX = 0; camTargetY = 0;
        dying = false; particles = []; floatingTexts = [];
        screenFlash = 0; playerScale = 1; playerScaleTarget = 1;
        playerAngle = 0; playerBreath = 0;
        shakeX = 0; shakeY = 0; shakeDecay = 0;
        hintVisible = true; hintEl.style.opacity = '1';

        cellMap.clear(); trail.clear();

        scoreEl.textContent = '0';
        levelEl.textContent = 'Level 1';
        comboText.classList.remove('visible');
        updateLivesUI();

        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';

        playerColor = getCellColor(0, 0);
        genNextColors();
        cycleStart = performance.now();
        updateColorUI(); updateNextUI();

        gameRunning = true;
        startDrone();
        startHeartbeat();
    }

    // ============================================================
    //  INPUT
    // ============================================================
    document.addEventListener('keydown', (e) => {
        const map = {
            ArrowRight:'right', ArrowLeft:'left', ArrowDown:'down', ArrowUp:'up',
            d:'right', a:'left', s:'down', w:'up', D:'right', A:'left', S:'down', W:'up',
        };
        if (map[e.key]) { e.preventDefault(); move(map[e.key]); }
        if ((e.key === ' ' || e.key === 'Enter') &&
            (gameOverScreen.style.display === 'flex' || startScreen.style.display === 'flex')) {
            e.preventDefault(); startGame();
        }
    });

    ['up','down','left','right'].forEach(dir => {
        const el = document.getElementById('dpad-' + dir);
        el.addEventListener('touchstart', (e) => { e.preventDefault(); move(dir); });
        el.addEventListener('click', () => move(dir));
    });

    let tSX = 0, tSY = 0, tST = 0;
    canvas.addEventListener('touchstart', (e) => {
        e.preventDefault();
        tSX = e.touches[0].clientX; tSY = e.touches[0].clientY; tST = performance.now();
    }, { passive: false });
    canvas.addEventListener('touchend', (e) => {
        e.preventDefault();
        const dx = e.changedTouches[0].clientX - tSX;
        const dy = e.changedTouches[0].clientY - tSY;
        if (performance.now() - tST > 500) return;
        if (Math.max(Math.abs(dx), Math.abs(dy)) < 25) return;
        move(Math.abs(dx) > Math.abs(dy) ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up'));
    }, { passive: false });

    // Prevent all unwanted mobile behaviors (scroll bounce, zoom)
    document.addEventListener('touchmove', (e) => {
        if (e.target.id !== 'player-name' && !e.target.closest('#leaderboard')) e.preventDefault();
    }, { passive: false });
    document.addEventListener('gesturestart', (e) => e.preventDefault());
    document.addEventListener('gesturechange', (e) => e.preventDefault());

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    // Enter in name input → save & restart
    playerNameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); startGame(); }
        // Block game keys while typing
        e.stopPropagation();
    });

    // ============================================================
    //  INIT
    // ============================================================
    playerColor = 0;
    updateColorUI();
    genNextColors();
    renderLeaderboard(-1);
    requestAnimationFrame(loop);
})();
</script>
</body>
</html>
